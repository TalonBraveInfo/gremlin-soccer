#include "RAGE Object.h"#include "RAGE Maths3D.h"#include "RAGE Utilities.h"/*****************************************************************	Static Globals*****************************************************************/static Position		gCameraLocation;static Matrix4x3	gCameraTransform;static float		gHither, gYon;static float		gClipLeft, gClipRight, gClipTop, gClipBottom;static float		gClipWidth, gClipHeight, gClipCenterH, gClipCenterV;/*****************************************************************	Routines to Manipulate Cameras*****************************************************************/void SetCameraLocation (Position *inPosition){	gCameraLocation = *inPosition;}void GetCameraLocation (Position *outPosition){	*outPosition = gCameraLocation;}void CalculateCameraTransform (void){	Matrix4x3	tempTransform1, rotateMatrix;	float cosRoll, sinRoll, cosPitch, sinPitch, cosYaw, sinYaw;	SetIdentityMatrix (&gCameraTransform);		cosRoll  = gCosAngleArray[(720-2*gCameraLocation.roll) ];	sinRoll  = gSinAngleArray[(720-2*gCameraLocation.roll) ];	cosPitch = gCosAngleArray[(720-2*gCameraLocation.pitch) ];	sinPitch = gSinAngleArray[(720-2*gCameraLocation.pitch) ];	cosYaw   = gCosAngleArray[(720-2*gCameraLocation.yaw) ];	sinYaw   = gSinAngleArray[(720-2*gCameraLocation.yaw) ];		SetIdentityMatrix (&tempTransform1);	tempTransform1.value[3][0] -= gCameraLocation.x;	tempTransform1.value[3][1] -= gCameraLocation.y;	tempTransform1.value[3][2] -= gCameraLocation.z;		// Create a matrix for the rotations of the object;	SetIdentityMatrix (&rotateMatrix);	rotateMatrix.value[0][0] = cosRoll;	rotateMatrix.value[0][1] = sinRoll;	rotateMatrix.value[1][0] = -sinRoll;	rotateMatrix.value[1][1] = cosRoll;		MultiplyMatrixToMatrix (&tempTransform1, &rotateMatrix, &gCameraTransform);		SetIdentityMatrix (&rotateMatrix);	rotateMatrix.value[0][0] = cosYaw;	rotateMatrix.value[0][2] = -sinYaw;	rotateMatrix.value[2][0] = sinYaw;	rotateMatrix.value[2][2] = cosYaw;		MultiplyMatrixToMatrix (&gCameraTransform, &rotateMatrix, &tempTransform1);		SetIdentityMatrix (&rotateMatrix);	rotateMatrix.value[1][1] = cosPitch;	rotateMatrix.value[1][2] = sinPitch;	rotateMatrix.value[2][1] = -sinPitch;	rotateMatrix.value[2][2] = cosPitch;		MultiplyMatrixToMatrix (&tempTransform1, &rotateMatrix, &gCameraTransform);}void SetZExtents (float hither, float yon){	gHither = hither;	gYon = yon;}void SetClipRect (TQARect *clip){	gClipLeft = (float) clip->left;	gClipRight = (float) clip->right;	gClipTop = (float) clip->top;	gClipBottom = (float) clip->bottom;	gClipWidth = gClipRight - gClipLeft;	gClipHeight = gClipBottom - gClipTop;	gClipCenterH = gClipWidth/2;	gClipCenterV = gClipHeight/2;}/*****************************************************************	Routines to Manipulate Objects*****************************************************************/void TransformObjectToWorld (RawObject *object){	int 		loop;	long		verts = object->numVertices;	Matrix4x3	tempTransform1, tempTransform2, rotateMatrix;		float cosRoll, sinRoll, cosPitch, sinPitch, cosYaw, sinYaw;		cosRoll  = gCosAngleArray[2*object->location.roll];	sinRoll  = gSinAngleArray[2*object->location.roll];	cosPitch = gCosAngleArray[2*object->location.pitch];	sinPitch = gSinAngleArray[2*object->location.pitch];	cosYaw   = gCosAngleArray[2*object->location.yaw];	sinYaw   = gSinAngleArray[2*object->location.yaw];		SetIdentityMatrix (&tempTransform2);	tempTransform2.value[0][0] = cosRoll;	tempTransform2.value[0][1] = sinRoll;	tempTransform2.value[1][0] = -sinRoll;	tempTransform2.value[1][1] = cosRoll;		SetIdentityMatrix (&rotateMatrix);	rotateMatrix.value[0][0] = cosYaw;	rotateMatrix.value[0][2] = -sinYaw;	rotateMatrix.value[2][0] = sinYaw;	rotateMatrix.value[2][2] = cosYaw;		MultiplyMatrixToMatrix (&tempTransform2, &rotateMatrix, &tempTransform1);		SetIdentityMatrix (&rotateMatrix);	rotateMatrix.value[1][1] = cosPitch;	rotateMatrix.value[1][2] = sinPitch;	rotateMatrix.value[2][1] = -sinPitch;	rotateMatrix.value[2][2] = cosPitch;		MultiplyMatrixToMatrix (&tempTransform1, &rotateMatrix, &tempTransform2);		tempTransform2.value[3][0] += object->location.x;	tempTransform2.value[3][1] += object->location.y;	tempTransform2.value[3][2] += object->location.z;		for (loop = 0; loop < verts; loop++)	{		object->converted[loop] = object->base[loop];		MultiplyMatrixToPoint ((Point3D *)&(object->converted[loop]), &tempTransform2);	}		}void TransformObjectToCamera (RawObject *object){	int 	loop;	long	verts = object->numVertices;		for (loop = 0; loop < verts; loop++)	{		// we take advantage of the fact that the first 3 coordinates of the RAVE		// points are x,y,z, same as our Point3D structure we defined in our matrix routines		MultiplyMatrixToPoint ((Point3D *)&(object->converted[loop]), &gCameraTransform);	}}Boolean ClipObjectToZ (RawObject *object){	int		loop;	long	verts = object->numVertices;		for (loop = 0; loop < verts; loop++)	{		float i;				i = object->converted[loop].z;		if ((i < gHither) || (i > gYon))			return false;	}		return true;}void ProjectObject (RawObject *object){	int		loop;	long	verts = object->numVertices;		for (loop = 0; loop < verts; loop++)	{		TQAVGouraud *pt;				pt = &object->converted[loop];				pt->x = pt->x * gClipWidth / pt->z + gClipCenterH;		pt->y = pt->y * gClipHeight / pt->z + gClipCenterV;		pt->z = pt->z / gYon;	}}void DrawObject (RawObject *object, TQADrawContext *theContext){	// Take each polygon in the object, build a ClippedPolygon structure, pass it to the	// the clipping routine and then pass the final polygon to RAVE.  Alternately, could	// pass to a routine that builds a list of polygons, if wanted to do use painters	// algorithm.  In fact,a constant is defined in the header file to max out the 	// # of polygons in the frame.  We don't actually use this value in this code.		int				polyLoop, vertLoop;	ClippedPolygon	drawPoly;	RawPolygon		*currentPoly;		int				polys, verts;		polys = object->numPolygons;		for (polyLoop = 0; polyLoop < polys; polyLoop++)	{		currentPoly = &(object->polygons[polyLoop]);		verts = currentPoly->numIndexes;		drawPoly.numVertices = verts;				for (vertLoop = 0; vertLoop < verts; vertLoop++)		{			drawPoly.verts[vertLoop] = object->converted[currentPoly->indexes[vertLoop]];		}				if (ClipPolygon (&drawPoly))		{			//drawPoly.verts[drawPoly.numVertices] = drawPoly.verts[0];			QADrawVGouraud (theContext, drawPoly.numVertices, kQAVertexMode_Fan,&drawPoly.verts[0], NULL);		}	}	}//gClipLeft, gClipRight, gClipTop, gClipBottom;/*****************************************************************	Routines to Manipulate Polygons*****************************************************************/Boolean ClipPolygon (ClippedPolygon *poly)  // returns false if the polygon is not on screen.{	ClippedPolygon temp;	ClippedPolygon *ptr1, *ptr2;	int vertLoop, nextVert;	Boolean clipCurrent, clipNext;		ptr1 = poly;	ptr2 = &temp;	// We'll walk the list of vertices four times, once for each side of the clipping rectangle.	// As we walk the list of vertices, we write out a new list of vertices.  We'll alternate	// reading and writing between the two buffers.		/******  Clipping on the left side ******/	ptr2->numVertices = 0;		for (vertLoop = 0; vertLoop < ptr1->numVertices; vertLoop++)	{		nextVert = (vertLoop+1) % ptr1->numVertices;		clipCurrent = (ptr1->verts[vertLoop].x < gClipLeft);		clipNext    = (ptr1->verts[nextVert].x < gClipLeft);				if (!clipCurrent)		{			// If we don't clip the current vertice, then we always add it to the list.			ptr2->verts[ptr2->numVertices] = ptr1->verts[vertLoop];			ptr2->numVertices++;		}				if (clipCurrent != clipNext)		{			float para;						ptr2->verts[ptr2->numVertices].x = gClipLeft;						para = ( gClipLeft - ptr1->verts[vertLoop].x) /							 (ptr1->verts[nextVert].x - ptr1->verts[vertLoop].x);								 			ptr2->verts[ptr2->numVertices].y = ptr1->verts[vertLoop].y + para * (ptr1->verts[nextVert].y - ptr1->verts[vertLoop].y);			ptr2->verts[ptr2->numVertices].z = ptr1->verts[vertLoop].z + para * (ptr1->verts[nextVert].z - ptr1->verts[vertLoop].z);			ptr2->verts[ptr2->numVertices].a = ptr1->verts[vertLoop].a + para * (ptr1->verts[nextVert].a - ptr1->verts[vertLoop].a);			ptr2->verts[ptr2->numVertices].r = ptr1->verts[vertLoop].r + para * (ptr1->verts[nextVert].r - ptr1->verts[vertLoop].r);			ptr2->verts[ptr2->numVertices].g = ptr1->verts[vertLoop].g + para * (ptr1->verts[nextVert].g - ptr1->verts[vertLoop].g);			ptr2->verts[ptr2->numVertices].b = ptr1->verts[vertLoop].b + para * (ptr1->verts[nextVert].b - ptr1->verts[vertLoop].b);							ptr2->numVertices++;		}	}		if (ptr2->numVertices == 0)		return false;	ptr1 = &temp;	ptr2 = poly;	// We'll walk the list of vertices four times, once for each side of the clipping rectangle.	// As we walk the list of vertices, we write out a new list of vertices.  We'll alternate	// reading and writing between the two buffers.		/******  Clipping on the right side ******/	ptr2->numVertices = 0;		for (vertLoop = 0; vertLoop < ptr1->numVertices; vertLoop++)	{		nextVert = (vertLoop+1) % ptr1->numVertices;		clipCurrent = (ptr1->verts[vertLoop].x > gClipRight);		clipNext    = (ptr1->verts[nextVert].x > gClipRight);				if (!clipCurrent)		{			// If we don't clip the current vertice, then we always add it to the list.			ptr2->verts[ptr2->numVertices] = ptr1->verts[vertLoop];			ptr2->numVertices++;		}				if (clipCurrent != clipNext)		{			float para;						ptr2->verts[ptr2->numVertices].x = gClipRight;						para = ( gClipRight -  ptr1->verts[vertLoop].x) /							 (ptr1->verts[nextVert].x - ptr1->verts[vertLoop].x);								 			ptr2->verts[ptr2->numVertices].y = ptr1->verts[vertLoop].y + para * (ptr1->verts[nextVert].y - ptr1->verts[vertLoop].y);			ptr2->verts[ptr2->numVertices].z = ptr1->verts[vertLoop].z + para * (ptr1->verts[nextVert].z - ptr1->verts[vertLoop].z);			ptr2->verts[ptr2->numVertices].a = ptr1->verts[vertLoop].a + para * (ptr1->verts[nextVert].a - ptr1->verts[vertLoop].a);			ptr2->verts[ptr2->numVertices].r = ptr1->verts[vertLoop].r + para * (ptr1->verts[nextVert].r - ptr1->verts[vertLoop].r);			ptr2->verts[ptr2->numVertices].g = ptr1->verts[vertLoop].g + para * (ptr1->verts[nextVert].g - ptr1->verts[vertLoop].g);			ptr2->verts[ptr2->numVertices].b = ptr1->verts[vertLoop].b + para * (ptr1->verts[nextVert].b - ptr1->verts[vertLoop].b);							ptr2->numVertices++;		}	}	if (ptr2->numVertices == 0)		return false;	ptr1 = poly;	ptr2 = &temp;	// We'll walk the list of vertices four times, once for each side of the clipping rectangle.	// As we walk the list of vertices, we write out a new list of vertices.  We'll alternate	// reading and writing between the two buffers.		/******  Clipping on the top side ******/	ptr2->numVertices = 0;		for (vertLoop = 0; vertLoop < ptr1->numVertices; vertLoop++)	{		nextVert = (vertLoop+1) % ptr1->numVertices;		clipCurrent = (ptr1->verts[vertLoop].y < gClipTop);		clipNext    = (ptr1->verts[nextVert].y < gClipTop);				if (!clipCurrent)		{			// If we don't clip the current vertice, then we always add it to the list.			ptr2->verts[ptr2->numVertices] = ptr1->verts[vertLoop];			ptr2->numVertices++;		}				if (clipCurrent != clipNext)		{			float para;						ptr2->verts[ptr2->numVertices].y = gClipTop;						para = (gClipTop - ptr1->verts[vertLoop].y) /								 (ptr1->verts[nextVert].y - ptr1->verts[vertLoop].y);								 			ptr2->verts[ptr2->numVertices].x = ptr1->verts[vertLoop].x + para * (ptr1->verts[nextVert].x - ptr1->verts[vertLoop].x);			ptr2->verts[ptr2->numVertices].z = ptr1->verts[vertLoop].z + para * (ptr1->verts[nextVert].z - ptr1->verts[vertLoop].z);			ptr2->verts[ptr2->numVertices].a = ptr1->verts[vertLoop].a + para * (ptr1->verts[nextVert].a - ptr1->verts[vertLoop].a);			ptr2->verts[ptr2->numVertices].r = ptr1->verts[vertLoop].r + para * (ptr1->verts[nextVert].r - ptr1->verts[vertLoop].r);			ptr2->verts[ptr2->numVertices].g = ptr1->verts[vertLoop].g + para * (ptr1->verts[nextVert].g - ptr1->verts[vertLoop].g);			ptr2->verts[ptr2->numVertices].b = ptr1->verts[vertLoop].b + para * (ptr1->verts[nextVert].b - ptr1->verts[vertLoop].b);							ptr2->numVertices++;		}	}	if (ptr2->numVertices == 0)		return false;	ptr1 = &temp;	ptr2 = poly;	// We'll walk the list of vertices four times, once for each side of the clipping rectangle.	// As we walk the list of vertices, we write out a new list of vertices.  We'll alternate	// reading and writing between the two buffers.		/******  Clipping on the bottom side ******/	ptr2->numVertices = 0;		for (vertLoop = 0; vertLoop < ptr1->numVertices; vertLoop++)	{		nextVert = (vertLoop+1) % ptr1->numVertices;		clipCurrent = (ptr1->verts[vertLoop].y > gClipBottom);		clipNext    = (ptr1->verts[nextVert].y > gClipBottom);				if (!clipCurrent)		{			// If we don't clip the current vertice, then we always add it to the list.			ptr2->verts[ptr2->numVertices] = ptr1->verts[vertLoop];			ptr2->numVertices++;		}				if (clipCurrent != clipNext)		{			float para;						ptr2->verts[ptr2->numVertices].y = gClipBottom;						para = (gClipBottom - ptr1->verts[vertLoop].y ) /								 (ptr1->verts[nextVert].y - ptr1->verts[vertLoop].y);								 			ptr2->verts[ptr2->numVertices].x = ptr1->verts[vertLoop].x + para * (ptr1->verts[nextVert].x - ptr1->verts[vertLoop].x);			ptr2->verts[ptr2->numVertices].z = ptr1->verts[vertLoop].z + para * (ptr1->verts[nextVert].z - ptr1->verts[vertLoop].z);			ptr2->verts[ptr2->numVertices].a = ptr1->verts[vertLoop].a + para * (ptr1->verts[nextVert].a - ptr1->verts[vertLoop].a);			ptr2->verts[ptr2->numVertices].r = ptr1->verts[vertLoop].r + para * (ptr1->verts[nextVert].r - ptr1->verts[vertLoop].r);			ptr2->verts[ptr2->numVertices].g = ptr1->verts[vertLoop].g + para * (ptr1->verts[nextVert].g - ptr1->verts[vertLoop].g);			ptr2->verts[ptr2->numVertices].b = ptr1->verts[vertLoop].b + para * (ptr1->verts[nextVert].b - ptr1->verts[vertLoop].b);							ptr2->numVertices++;		}		}	if (ptr2->numVertices == 0)		return false;	return true;}