#include "Mac Vars.h"#include "3deng.h"#include "RAGE Starter Code.h"//#include "RAGE Common Stuff.h"#undef EXTERN#define EXTERN extern#include "RAGE Utilities.h"#include "Blitter.h"#include "Palette.h"#include "Process Inputs.h"#include "Vbl.h"#if USERAVEENGINE==YESextern float RAGE_cur_camx;extern float RAGE_cur_camz;extern float RAGE_cur_camy;extern float RAGE_cur_tx;extern float RAGE_cur_tz;extern float RAGE_cur_ty;#endif#if USERAVEENGINE==YES// globals for Rave accessTQAEngine 			*gTheEngine = NULL;TQADrawContext		*gTheContext = NULL;TQATexture			*Texture_Maps[11];//char				EngineName[8][128];//long				OptionalFeatures[8];//long				FastFeatures[8];short				ThisEngineNumber = 0;short				NumberOfEngines = 0;short				TextureQuality = 0;short				AliasQuality = 0;//static Boolean TextureSizes[]={ true, false, false, false, true, true, true, false, false, true };static Boolean TextureSizes[]={ true, true, true, true, true, true, true, true, true, true };static Boolean Transparent[]={ true, true, true, true, true, true, false, false, false, false };//static short   TextureFilters[] = { kQATextureFilter_Fast, kQATextureFilter_Mid, kQATextureFilter_Best };//static short   AliasFilters[] = { kQAAntiAlias_Off, kQAAntiAlias_Fast, kQAAntiAlias_Mid, kQAAntiAlias_Best};extern GDHandle		gameScreen;extern BYTE 	   *sky;extern int			mmenu;extern void 		RenderPitchSky( datapt viewx, datapt viewy, datapt viewz, datapt targx, datapt targy, datapt targz, BYTE *buffer, int width);extern Boolean		Scanner;extern int 			oslide;extern short		dataResRave;extern short		mainResFile;typedef TQATexture		   *Texture_Maps[11];static void SetPalette( int colour, int r, int g, int b, int cnt){	colour *=3;	while( cnt--)		{		palette_buffer[colour++] = r;		palette_buffer[colour++] = g;		palette_buffer[colour++] = b;		}}typedef BYTE mappage[256*256];extern mappage		*maps;void DumpTga( void *buffer, int x, int y);static void RAGE_LoadTexturesToMemory(){long available, available2;int a = 0;short res = CurResFile();	QAEngineGestalt( gTheEngine, kQAGestalt_TextureMemory, &available);	QAEngineGestalt( gTheEngine, kQAGestalt_FastTextureMemory, &available2);/*	Blackburn Rovers *///	SetPalette( 32, 0, 0, 63, 4);//	SetPalette( 36, 63, 63, 63, 4);//	SetPalette( 40, 0, 0, 63, 4);//	SetPalette( 44, 63, 63, 63, 4);//	SetPalette( 48, 63, 63, 63, 3);/* Man United *///	SetPalette( 32, 63, 0, 0, 16);//	SetPalette( 48, 63, 63, 63, 3);	CreateTexturePalette();		UseResFile( dataResRave);#if DEBUGGING==YES//	LoadPictureToMap( 136, 1);//	LoadPictureToMap( 136, 2); 	for( ; a<10; a++)		Texture_Maps[a] = CreateTextureFromMaps ( gTheEngine, a, TextureSizes[a], Transparent[a]);	Texture_Maps[10] = CreateTextureFromPict( gTheEngine, 135);#else	memset( TextureSizes, false, sizeof(TextureSizes) );//	LoadPictureToMap( 136, 1);//	LoadPictureToMap( 136, 2); 	for( ; a<8; a++)		Texture_Maps[a] = CreateTextureFromMaps ( gTheEngine, a, TextureSizes[a], Transparent[a]);	Texture_Maps[9] = CreateTextureFromPict( gTheEngine, 134);	Texture_Maps[10] = CreateTextureFromPict( gTheEngine, 135);	Texture_Maps[8] = CreateTextureFromMaps( gTheEngine, 8, TextureSizes[8], Transparent[8]);#endif	UseResFile( res);	QAEngineGestalt( gTheEngine, kQAGestalt_TextureMemory, &available);	QAEngineGestalt( gTheEngine, kQAGestalt_FastTextureMemory, &available2);}void ReloadTextureMap( int Map){	QATextureDelete( gTheEngine, Texture_Maps[ Map]);	CreateTexturePalette();	Texture_Maps[ Map] = CreateTextureFromMaps ( gTheEngine, Map, TextureSizes[ Map], Transparent[ Map]);}static void RAGE_ReloadTextures( const TQADrawContext *drawContext, const TQADevice *buffer, const TQARect *dirtyRect, void *refCon){#pragma unused (drawContext)#pragma unused (buffer)#pragma unused (dirtyRect)#pragma unused (refCon)	RAGE_LoadTexturesToMemory();}static void RAGE_Initialize( const TQADrawContext *drawContext, const TQADevice *buffer, const TQARect *dirtyRect, void *refCon){#pragma unused (drawContext)#pragma unused (dirtyRect)#pragma unused (refCon)TQADeviceMemory const *memory = NULL;	memory = &buffer->device.memoryDevice;	RenderPitchSky( RAGE_cur_camx, RAGE_cur_camz, RAGE_cur_camy, RAGE_cur_tx, RAGE_cur_tz, RAGE_cur_ty, (BYTE *)memory->baseAddr, memory->rowBytes);}unsigned short Conversion[]= { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0003							  ,0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000A, 0x000B							  ,0x000C, 0x000D, 0x000E, 0x000F, 0x0010, 0x0011, 0x0012, 0x0013							  ,0x0014, 0x0015, 0x0016, 0x0017, 0x0018, 0x0019, 0x001a, 0x001b};static void ScreenCopy( int x, int y, int w, int h, BYTE *buffer, int width){BYTE *src;unsigned short *scr;int a;BYTE c;	src = (BYTE *)screenptr + x + (y*640);	scr = (unsigned short *)(buffer + (x+x) + (y*width));	width/=2;		while( h--)		{		for( a=0 ; a<w; a++)			{			c = src[a];			if( c)				{				scr[a] = palette_buffer16[ c ] ;				src[a] = 0;				}//			else//				{//				scr[a] = (Conversion[(scr[a]>>10)&31]<<10) | (Conversion[(scr[a]>>5)&31]<<5) | (Conversion[(scr[a]&31)]) | ( scr[a]&0x8000);//				}			}		scr += width;		src += 640;		}}static void RAGE_Composite( const TQADrawContext *drawContext, const TQADevice *buffer, const TQARect *dirtyRect, void *refCon){#pragma unused (drawContext)#pragma unused (buffer)#pragma unused (dirtyRect)#pragma unused (refCon)TQADeviceMemory const *memory = NULL;Ptr rowPtr = NULL;//long width, height;long offset;//unsigned short *pixelPtr = NULL;	memory = &buffer->device.memoryDevice;	rowPtr = (Ptr) memory->baseAddr;	offset = memory->rowBytes;//	width = memory->width;//	height = memory->height;//	pixelPtr = (UInt16 *) rowPtr;	ScreenCopy( 0, 0, 640, 22, (BYTE *)rowPtr, offset);		if( mmenu)		ScreenCopy(0, 479-((12+oslide)*2), 640, ((12+oslide)*2), (BYTE *)rowPtr, offset);	else 		ScreenCopy(50, 465, 540, 15, (BYTE *)rowPtr, offset);		if( Scanner)		ScreenCopy(15, 370, 75, 96, (BYTE *)rowPtr, offset);	memset( ((BYTE *)rowPtr)+479*offset, 0, 1280);}Boolean RAGE_Available( GDHandle	mainDevice){OSErr			theErr = noErr;TQAError		theQAErr = kQANoErr;GDHandle		device = NULL;WindowRef		theWindow = NULL;Rect			deviceRect;TQADevice		qaDevice;long			FastFeatures;long			OptionalFeatures;char			EngineName[128];	deviceRect = (**mainDevice).gdRect;	qaDevice.deviceType = kQADeviceGDevice;	qaDevice.device.gDevice = mainDevice;//	QAEngineEnable (kQAVendor_Apple,kQAEngine_AppleHW);	NumberOfEngines = 0;	gTheEngine = QADeviceGetFirstEngine (&qaDevice);	while( gTheEngine)		{/*		theQAErr = QAEngineGestalt( gTheEngine, kQAGestalt_ASCIIName, &EngineName);		theQAErr = QAEngineGestalt( gTheEngine, kQAGestalt_OptionalFeatures, &OptionalFeatures);		theQAErr = QAEngineGestalt( gTheEngine, kQAGestalt_FastFeatures, &FastFeatures);				printf("Engine '%s'\n", EngineName);		if( OptionalFeatures)								printf("  Optional Features\n");		if( kQAOptional_DeepZ & OptionalFeatures)			printf("    Deep Z\n");		if( kQAOptional_Texture & OptionalFeatures)			printf("    Texture\n");		if( kQAOptional_TextureHQ & OptionalFeatures)		printf("    Texture HQ\n");		if( kQAOptional_TextureColor & OptionalFeatures)	printf("    Texture Colour\n");		if( kQAOptional_Blend & OptionalFeatures)			printf("    Blend\n");		if( kQAOptional_BlendAlpha & OptionalFeatures)		printf("    Blend Alpha\n");		if( kQAOptional_Antialias & OptionalFeatures)		printf("    Anti Alias\n");		if( kQAOptional_ZSorted & OptionalFeatures)			printf("    Z Sorted\n");		if( kQAOptional_PerspectiveZ & OptionalFeatures)	printf("    PerspectiveZ\n");		if( kQAOptional_OpenGL & OptionalFeatures)			printf("    OpenGL\n");		if( kQAOptional_NoClear & OptionalFeatures)			printf("    No Clear\n");				if( FastFeatures)									printf("  Fast Features\n");		if( kQAFast_Line & FastFeatures)					printf("    Fast Line\n");		if( kQAFast_Gouraud & FastFeatures)					printf("    Gouraud\n");		if( kQAFast_Texture & FastFeatures)					printf("    Texture\n");		if( kQAFast_TextureHQ & FastFeatures)				printf("    Texture HQ\n");		if( kQAFast_Blend & FastFeatures)					printf("    Blend\n");		if( kQAFast_Antialiasing & FastFeatures)			printf("    Anti Aliasing\n");		if( kQAFast_ZSorted & FastFeatures)					printf("    Z Sorted\n");		printf("\n\n");*///		theQAErr = QAEngineGestalt( gTheEngine, kQAGestalt_ASCIIName, &EngineName); // &EngineName[ NumberOfEngines]);//		theQAErr = QAEngineGestalt( gTheEngine, kQAGestalt_OptionalFeatures, &OptionalFeatures); // &OptionalFeatures[ NumberOfEngines]);		theQAErr = QAEngineGestalt( gTheEngine, kQAGestalt_FastFeatures, &FastFeatures); //&FastFeatures[ NumberOfEngines]);		if( FastFeatures/*[NumberOfEngines]*/ & kQAFast_Texture)			NumberOfEngines++;		gTheEngine = QADeviceGetNextEngine( &qaDevice, gTheEngine);		}	ThisEngineNumber = 0;		if( NumberOfEngines)		return true;	return false;}int RAGE_Init3D(){long available;long performance;	SetupRave( gameScreen);		init3d_gremlin();		RAGE_LoadTexturesToMemory();	//	QASetInt (gTheContext, kQATag_TextureFilter, TextureFilters[ TextureQuality]);//	QASetInt (gTheContext, kQATag_Antialias, AliasFilters[ AliasQuality]);	Timing = false;	performance = TickCount();	VblTicks = 0;	while((TickCount()-performance)<60)	// one second for timing		;	TicksPerSecond = VblTicks;	Timing = true;	return true;}void end3d_rave(){	for( int a=0; a<10; a++)		QATextureDelete( gTheEngine, Texture_Maps[a]);			if ( gTheContext)		QADrawContextDelete( gTheContext);	gTheContext = NULL;}OSErr SetupRave(GDHandle	mainDevice){Rect bounds;Rect deviceRect;// These hold our errorsOSErr			theErr = noErr;	// These hold the window and device we'll put on the screenGDHandle		device = NULL;WindowRef		theWindow = NULL;// We use these parameters to describe our environment to RAVETQADevice		qaDevice;TQAError		theQAErr = kQANoErr;TQARect 		qaBoundsRect;	short			whichEngine = ThisEngineNumber;TQANoticeMethod noticeMethod;	// Center our bounds in the middle of the screen.	deviceRect = (**mainDevice).gdRect;		bounds.left = 0;	bounds.right = 639;	bounds.top = 0;	bounds.bottom = 479;		OffsetRect (&bounds,					(deviceRect.right+deviceRect.left-bounds.right)/2,					(deviceRect.bottom+deviceRect.top-bounds.bottom)/2);						// Next we need to find a RAVE engine and then build a DrawContext to draw into it.  First, we'll find	// an engine that is capable of drawing to the selected GDevice.	qaDevice.deviceType = kQADeviceGDevice;	qaDevice.device.gDevice = mainDevice;		// We have to explicitly enable the Apple hardware card because it isn't 100% RAVE compliant.  If this	// engine comes up, we have to write special case code to deal with it.//	QAEngineEnable (kQAVendor_Apple,kQAEngine_AppleHW);		gTheEngine = QADeviceGetFirstEngine (&qaDevice);//	FAIL_NULL (gTheEngine, "\pERROR:  No RAVE engines available.")	if( !gTheEngine)		goto error;	while( whichEngine--)		gTheEngine = QADeviceGetNextEngine (&qaDevice, gTheEngine);		qaBoundsRect.left = bounds.left - deviceRect.left;	qaBoundsRect.right = bounds.right  - deviceRect.left;	qaBoundsRect.top = bounds.top - deviceRect.top;	qaBoundsRect.bottom = bounds.bottom - deviceRect.top;	theQAErr = QADrawContextNew (&qaDevice, &qaBoundsRect, NULL, gTheEngine, #if DEBUGGING==YES								 kQAContext_NoZBuffer, &gTheContext);#else								 kQAContext_NoZBuffer | kQAContext_DoubleBuffer, &gTheContext);#endif	FAIL_FALSE ((theQAErr == kQANoErr), "\pERROR:  Failed to create RAVE draw context")	FAIL_NULL (gTheContext, "\pERROR:  Failed to create RAVE draw context")		// Setup Notice Methods	noticeMethod.bufferNoticeMethod = RAGE_Initialize;	theQAErr = QASetNoticeMethod ( gTheContext, kQAMethod_BufferInitialize, noticeMethod ,NULL);	noticeMethod.bufferNoticeMethod = RAGE_Composite;	theQAErr = QASetNoticeMethod ( gTheContext, kQAMethod_BufferComposite, noticeMethod ,NULL);	noticeMethod.bufferNoticeMethod = RAGE_ReloadTextures;	theQAErr = QASetNoticeMethod ( gTheContext, kQAMethod_ReloadTextures, noticeMethod ,NULL);	// set the background to black	QASetFloat (gTheContext, kQATag_ColorBG_a, 1.0);	QASetFloat (gTheContext, kQATag_ColorBG_r, 0.0);	QASetFloat (gTheContext, kQATag_ColorBG_g, 0.0);	QASetFloat (gTheContext, kQATag_ColorBG_b, 0.0);	return noErr;error:	// Either we got an error or the user finished.  In any case, tear everything down and return	if (gTheContext != NULL)		QADrawContextDelete (gTheContext);	if (theErr == noErr)		theErr = paramErr;	return theErr;}void RaveStartFrame(void) {	QARenderStart( gTheContext, NULL, NULL);}void RaveEndFrame(void) {TQAError theQAErr;	theQAErr = QARenderEnd( gTheContext, NULL);}void Fast_Block( int x, int y, int w, int h, float r, float g, float b){TQAVGouraud v[4];	v[0].z = v[1].z = v[2].z = v[3].z = 0.0;	v[0].invW = v[1].invW = v[2].invW = v[3].invW = 1.0;	v[0].r = v[1].r = v[2].r = v[3].r = r;	v[0].g = v[1].g = v[2].g = v[3].g = g;	v[0].b = v[1].b = v[2].b = v[3].b = b;	v[0].a = v[1].a = v[2].a = v[3].a = 1.0;	v[0].x = v[3].x = x;	v[0].y = v[1].y = y;		v[1].x = v[2].x = x+w;	v[2].y = v[3].y = y+h;	QADrawVGouraud (gTheContext, 4, kQAVertexMode_Fan, &v[0], NULL);}void Fast_Line( int x, int y, int x1, int y1, float r, float g, float b){TQAVGouraud v, v1;	v.z = v1.z = 0.0;	v.invW = v1.invW = 1.0;	v.r = v1.r = r;	v.g = v1.g = g;	v.b = v1.b = b;	v.a = v1.a = 1.0;	v.x = x;	v.y = y;	v1.x = x1;	v1.y = y1;	QADrawLine (gTheContext, &v, &v1);}#endif