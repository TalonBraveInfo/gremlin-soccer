#include "Mac Vars.h"#include "3deng.h"#include "RAGE Polygon Clipping.h"#undef EXTERN#define EXTERN extern#if USERAVEENGINE==YES#include "Rave.h"void xclippolygon(POLYGON *polygontoclip,POLYGON *clippedpolygon){VECTOR2D *vectorstoclip,*clippedvectors;VECTOR2D startvector,endvector;UVMAP *uvtoclip,*clippeduv;UVMAP startuv,enduv;short numvectorstoclip,numclippedvectors;short i;	vectorstoclip=polygontoclip->vectors;	uvtoclip=polygontoclip->uvmap;	numvectorstoclip=polygontoclip->numvectors;	clippedvectors=clippedpolygon->vectors;	clippeduv=clippedpolygon->uvmap;	numclippedvectors=0;	endvector=vectorstoclip[numvectorstoclip-1];	enduv=uvtoclip[numvectorstoclip-1];	for(i=0;i<numvectorstoclip;i++)		{		startvector=endvector;		startuv=enduv;		endvector=*vectorstoclip++;		enduv=*uvtoclip++;		if(startvector.x<WINDOW_MIN_X)			{			if(endvector.x>=WINDOW_MIN_X)				{				xcalc( &startvector, &endvector, clippedvectors, WINDOW_MIN_X,					   &startuv, &enduv, clippeduv);				clippedvectors++;				clippeduv++;				numclippedvectors++;				if(endvector.x>=WINDOW_MAX_X)					{					xcalc( &startvector, &endvector, clippedvectors, WINDOW_MAX_X-1,					       &startuv,     &enduv,     clippeduv);					clippedvectors++;					clippeduv++;					numclippedvectors++;					}				}			}		else			{			if(startvector.x<WINDOW_MAX_X)				{				*clippedvectors++=startvector;				*clippeduv++=startuv;				numclippedvectors++;				if(endvector.x<WINDOW_MIN_X)					{					xcalc(&startvector,&endvector,clippedvectors,WINDOW_MIN_X,						  &startuv, &enduv, clippeduv);					clippedvectors++;					clippeduv++;					numclippedvectors++;					}				else if(endvector.x>=WINDOW_MAX_X)					{					xcalc(&startvector,&endvector,clippedvectors,WINDOW_MAX_X-1,						  &startuv, &enduv, clippeduv);					clippedvectors++;					clippeduv++;					numclippedvectors++;					}				}			else				{				if(endvector.x<WINDOW_MAX_X)					{					xcalc(&startvector,&endvector,clippedvectors,WINDOW_MAX_X-1,						  &startuv, &enduv, clippeduv);					clippedvectors++;					clippeduv++;					numclippedvectors++;					}				if(endvector.x<WINDOW_MIN_X)					{					xcalc(&startvector,&endvector,clippedvectors,WINDOW_MIN_X,						  &startuv, &enduv, clippeduv);					clippedvectors++;					clippeduv++;					numclippedvectors++;					}				}			}		}	clippedpolygon->numvectors=numclippedvectors;	}void xcalc(VECTOR2D *startvector,VECTOR2D *endvector,VECTOR2D *newvector,short calcx, UVMAP *startuv, UVMAP *enduv, UVMAP *newuv){VECTOR2D d;UVMAP e;/* Make sure we always clip lines in the same direction *//* This reduces any mathematical errors that may appear */	if(startvector->x<endvector->x)		{		d.x=endvector->x-startvector->x;		d.y=endvector->y-startvector->y;		newvector->x=calcx-startvector->x;		newvector->y=((newvector->x*d.y)/d.x)+startvector->y;		e.u = enduv->u-startuv->u;		e.v = enduv->v-startuv->v;		newuv->u = startuv->u + ( (float)newvector->x/(float)d.x )*e.u;		newuv->v = startuv->v + ( (float)newvector->x/(float)d.x )*e.v;				newvector->x=calcx;		}	else		{		d.x=startvector->x-endvector->x;		d.y=startvector->y-endvector->y;		newvector->x=calcx-endvector->x;		newvector->y=((newvector->x*d.y)/d.x)+endvector->y;		e.u = startuv->u-enduv->u;		e.v = startuv->v-enduv->v;		newuv->u = enduv->u + ( (float)newvector->x/(float)d.x )*e.u;		newuv->v = enduv->v + ( (float)newvector->x/(float)d.x )*e.v;		newvector->x=calcx;		}	}void yclippolygon(POLYGON *polygontoclip,POLYGON *clippedpolygon){VECTOR2D *vectorstoclip,*clippedvectors;VECTOR2D startvector,endvector;UVMAP *uvtoclip,*clippeduv;UVMAP startuv,enduv;short numvectorstoclip,numclippedvectors;short i;	vectorstoclip=polygontoclip->vectors;	uvtoclip=polygontoclip->uvmap;	numvectorstoclip=polygontoclip->numvectors;	clippedvectors=clippedpolygon->vectors;	clippeduv=clippedpolygon->uvmap;	numclippedvectors=0;	endvector=vectorstoclip[numvectorstoclip-1];	enduv=uvtoclip[numvectorstoclip-1];	for(i=0;i<numvectorstoclip;i++)		{		startvector=endvector;		startuv=enduv;		endvector=*vectorstoclip++;		enduv = *uvtoclip++;				if(startvector.y<WINDOW_MIN_Y)			{			if(endvector.y>=WINDOW_MIN_Y)				{				ycalc(&startvector,&endvector,clippedvectors,WINDOW_MIN_Y,					   &startuv, &enduv, clippeduv);				clippedvectors++;				clippeduv++;				numclippedvectors++;				if(endvector.y>=WINDOW_MAX_Y)					{					ycalc(&startvector,&endvector,clippedvectors,WINDOW_MAX_Y-1,					       &startuv,     &enduv,     clippeduv);					clippedvectors++;					clippeduv++;					numclippedvectors++;					}				}			}		else			{			if(startvector.y<WINDOW_MAX_Y)				{				*clippedvectors++=startvector;				*clippeduv++=startuv;				numclippedvectors++;				if(endvector.y<WINDOW_MIN_Y)					{					ycalc(&startvector,&endvector,clippedvectors,WINDOW_MIN_Y,						  &startuv, &enduv, clippeduv);					clippedvectors++;					clippeduv++;					numclippedvectors++;					}				else if(endvector.y>=WINDOW_MAX_Y)					{					ycalc(&startvector,&endvector,clippedvectors,WINDOW_MAX_Y-1,						  &startuv, &enduv, clippeduv);					clippedvectors++;					clippeduv++;					numclippedvectors++;					}				}			else				{				if(endvector.y<WINDOW_MAX_Y)					{					ycalc(&startvector,&endvector,clippedvectors,WINDOW_MAX_Y-1,						  &startuv, &enduv, clippeduv);					clippedvectors++;					clippeduv++;					numclippedvectors++;					}				if(endvector.y<WINDOW_MIN_Y)					{					ycalc(&startvector,&endvector,clippedvectors,WINDOW_MIN_Y,						  &startuv, &enduv, clippeduv);					clippedvectors++;					clippeduv++;					numclippedvectors++;					}				}			}		}	clippedpolygon->numvectors=numclippedvectors;	}void ycalc(VECTOR2D *startvector,VECTOR2D *endvector,VECTOR2D *newvector,short calcy, UVMAP *startuv, UVMAP *enduv, UVMAP *newuv){VECTOR2D d;UVMAP e;/* Make sure we always clip lines in the same direction *//* This reduces any mathematical errors that may appear */	if(startvector->y<endvector->y)		{		d.x=endvector->x-startvector->x;		d.y=endvector->y-startvector->y;		newvector->y=calcy-startvector->y;		newvector->x=((newvector->y*d.x)/d.y)+startvector->x;		e.u = enduv->u-startuv->u;		e.v = enduv->v-startuv->v;		newuv->u = startuv->u + ( (float)newvector->y/(float)d.y )*e.u;		newuv->v = startuv->v + ( (float)newvector->y/(float)d.y )*e.v;		newvector->y=calcy;		}	else		{		d.x=startvector->x-endvector->x;		d.y=startvector->y-endvector->y;		newvector->y=calcy-endvector->y;		newvector->x=((newvector->y*d.x)/d.y)+endvector->x;		e.u = startuv->u-enduv->u;		e.v = startuv->v-enduv->v;		newuv->u = enduv->u + ( (float)newvector->y/(float)d.y )*e.u;		newuv->v = enduv->v + ( (float)newvector->y/(float)d.y )*e.v;		newvector->y=calcy;		}	}#endif