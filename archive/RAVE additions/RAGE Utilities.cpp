#include "Mac Vars.h"#if USERAVEENGINE==YES#include "RAGE Utilities.h"#include "RAGE Common Stuff.h"#undef EXTERN#define EXTERN extern#include "Blitter.h"#include "Palette.h"void CreateTexturePalette(){int i;BYTE *palette = (BYTE *)&palette_buffer;	for(i=0; i<256; i++)		{		palette[0] &= 63; palette[1] &= 63; palette[2] &= 63;		TexturePalette[i] = ((palette[0]>>1)<<10)|((palette[1]>>1)<<5)|((palette[2]>>1))|0x8000;		palette+=3;		}}static Boolean InTransparent( int y, int x, int map){	if( map == 6)		{		if( y<116)			return true;		if( y<143 && x>66)			return true;		if( y<171 && x>169)			return true;		}	else if( map == 8)		{		if( x <197)			return false;		if( y<100)			return false;		if( y<189)			return true;		if( y<224 && x>220)			return true;		}				return false;}TQATexture	*CreateTextureFromMaps (TQAEngine *engine, short map, Boolean Compress, Boolean Transparent){TQAImage	image;TQAError	theQAErr = kQANoErr;TQATexture	*texture= NULL;Handle		newDataH;BYTE		*oldData;WORD		*newData;	if( Compress)		{		newDataH = NewHandle( 128*128*2); HLockHi( newDataH);		image.width = 128;		image.height = 128;		image.rowBytes = 256;		image.pixmap = (void *)*newDataH;			newData = (WORD *)*newDataH;		oldData = maps[ map];			for( int a=0;a<256;a+=2)			{			for( int b=0;b<256;b+=2)				{				if( Transparent || InTransparent( a, b, map))					{					if( *oldData==1)						*newData++ = (TexturePalette[ (*oldData++)-1 ]) & 0x7fff;					else						*newData++ = (TexturePalette[ (*oldData++)-1 ]) | 0x8000;					}				else					*newData++ = TexturePalette[*oldData++];				oldData++;				}			oldData +=256;			}		theQAErr = QATextureNew ( engine, kQATexture_HighCompression, kQAPixel_ARGB16, &image, &texture);		}	else		{		newDataH = NewHandle( 256*256*2); HLockHi( newDataH);		image.width = 256;		image.height = 256;		image.rowBytes = 512;		image.pixmap = (void *)*newDataH;			newData = (WORD *)*newDataH;		oldData = maps[ map];			for( int a=0; a<255; a++)			{			for( int b=0; b<256; b++)				{				if( Transparent || InTransparent( a, b, map))					{					if( *oldData == 1)						*newData++ = (TexturePalette[ (*oldData++)-1 ]) & 0x7fff;					else						*newData++ = (TexturePalette[ (*oldData++)-1 ]) | 0x8000;					}				else					*newData++ = TexturePalette[*oldData++];				}			}		theQAErr = QATextureNew ( engine, kQATexture_HighCompression, kQAPixel_ARGB16, &image, &texture);		}	// We make RAVE allocate memory for the texture so that we can dispose of the GWorld.	theQAErr = QATextureDetach ( engine, texture); 	FAIL_FALSE ((theQAErr == kQANoErr), "\pFailed to detach the texture")		goto cleanup;error:	;	texture = NULL;cleanup:	;	if( newDataH)		DisposeHandle( newDataH);	return texture;}TQATexture	*CreateTextureFromPict(TQAEngine *engine, short pictID){PicHandle		picture = NULL;Rect			pictRect;	GWorldPtr		pictWorld = NULL;PixMapHandle	pictPix = NULL;	TQAImage		image;TQAError		theQAErr = kQANoErr;OSErr			theErr = noErr;TQATexture		*texture= NULL;	CGrafPtr		savePort = NULL;GDHandle		saveDevice = NULL;	short			*piccy;	// Load the texture from the resource;		picture = GetPicture (pictID);	theErr = ResError();	FAIL_NIL (picture, "\pERROR: Failed to load the texture resource")	FAIL_OSERR (theErr,"\pERROR: Failed to load the texture resource")		// Create a GWorld to hold the pix map data;	pictRect = (**picture).picFrame;	pictRect.right -= pictRect.left;	pictRect.left = 0;	pictRect.bottom -= pictRect.top;	pictRect.top = 0;		theErr = NewGWorld(&pictWorld, 16, &pictRect, NULL, NULL, NULL);	FAIL_OSERR (theErr, "\pCouldn't create the texture gworld")	pictPix = GetGWorldPixMap (pictWorld);	FAIL_NIL (pictPix, "\pCouldn't retrieve the texture's pixmap")	FAIL_FALSE (LockPixels (pictPix),"\pcouldn't lock the pixmap")		// Draw the picture into the GWorld	GetGWorld (&savePort, &saveDevice);	SetGWorld (pictWorld, NULL);		DrawPicture(picture, &pictRect);	SetGWorld (savePort, saveDevice);	// Create the texture		image.width = pictRect.right;	image.height = pictRect.bottom;	image.rowBytes = (**pictPix).rowBytes & 0x3FFF;	image.pixmap = GetPixBaseAddr (pictPix);	/*	piccy = (short *)image.pixmap;	for( int y=0; y<image.height; y++)		{		for( int x=0; x<image.width; x+=2)			piccy[x] = ((piccy[x]&0xf800)>>1)|(piccy[x]&0x03ff) | 0x8000;		piccy += image.rowBytes/2;		}*/	theQAErr = QATextureNew (engine,kQATexture_HighCompression ,kQAPixel_RGB16, &image, &texture);	FAIL_FALSE ((theQAErr == kQANoErr), "\pFailed to create the texture")		// We make RAVE allocate memory for the texture so that we can dispose of the GWorld.	theQAErr = QATextureDetach (engine, texture); 	FAIL_FALSE ((theQAErr == kQANoErr), "\pFailed to detach the texture")		// Succeeded in creating the texture, cleanup everything else and return	goto cleanup;	error:	// if we have a texture, dispose of it, because we want to return NULL	if (texture != NULL)		QATextureDelete (engine, texture);	texture = NULL;	cleanup:	if (picture != NULL)		ReleaseResource ((Handle) picture);	if (pictWorld != NULL)		DisposeGWorld (pictWorld);		return texture;		// Draw the picture into the pixmap}Boolean LoadPictureToMemory ( short pictID, char *where){PicHandle		picture = NULL;Rect			pictRect;GWorldPtr		pictWorld = NULL;PixMapHandle	pictPix = NULL;OSErr			theErr = noErr;CGrafPtr		savePort = NULL;GDHandle		saveDevice = NULL;char 			*newpicture;		// Load the texture from the resource;	picture = GetPicture (pictID);	theErr = ResError();	FAIL_NIL (picture, "\pERROR: Failed to load the texture resource")	FAIL_OSERR (theErr,"\pERROR: Failed to load the texture resource")		// Create a GWorld to hold the pix map data;	pictRect = (**picture).picFrame;	pictRect.right -= pictRect.left;	pictRect.left = 0;	pictRect.bottom -= pictRect.top;	pictRect.top = 0;		pictRect.right ++;	pictRect.bottom ++;		theErr = NewGWorld(&pictWorld, 16, &pictRect, NULL, NULL, NULL);	FAIL_OSERR (theErr, "\pCouldn't create the texture gworld")	pictPix = GetGWorldPixMap (pictWorld);	FAIL_NIL (pictPix, "\pCouldn't retrieve the texture's pixmap")	FAIL_FALSE (LockPixels (pictPix),"\pcouldn't lock the pixmap")		// Draw the picture into the GWorld	GetGWorld (&savePort, &saveDevice);	SetGWorld (pictWorld, NULL);	DrawPicture(picture, &pictRect);	SetGWorld (savePort, saveDevice);	newpicture = GetPixBaseAddr( pictPix);	for( int a=0; a<pictRect.bottom-1;a++)		{		memcpy( where, newpicture, 1280);		where += 1280;		newpicture += ((**pictPix).rowBytes & 0x3fff);		}	// Succeeded in creating the texture, cleanup everything else and return	goto cleanup;	error:	// if we have a texture, dispose of it, because we want to return NULLcleanup:	if (picture != NULL)		ReleaseResource ((Handle) picture);	if (pictWorld != NULL)		DisposeGWorld (pictWorld);	return true;}/*Boolean LoadPictureToMap ( short pictID, int map){PicHandle		picture = NULL;Rect			pictRect;GWorldPtr		pictWorld = NULL;PixMapHandle	pictPix = NULL;OSErr			theErr = noErr;CGrafPtr		savePort = NULL;GDHandle		saveDevice = NULL;char 			*newpicture;	char			*where = (char *)&maps[map];	// Load the texture from the resource;	picture = GetPicture (pictID);	theErr = ResError();	FAIL_NIL (picture, "\pERROR: Failed to load the texture resource")	FAIL_OSERR (theErr,"\pERROR: Failed to load the texture resource")		// Create a GWorld to hold the pix map data;	pictRect = (**picture).picFrame;	pictRect.right -= pictRect.left;	pictRect.left = 0;	pictRect.bottom -= pictRect.top;	pictRect.top = 0;		theErr = NewGWorld(&pictWorld, 8, &pictRect, NULL, NULL, NULL);	FAIL_OSERR (theErr, "\pCouldn't create the texture gworld")	pictPix = GetGWorldPixMap (pictWorld);	FAIL_NIL (pictPix, "\pCouldn't retrieve the texture's pixmap")	FAIL_FALSE (LockPixels (pictPix),"\pcouldn't lock the pixmap")		// Draw the picture into the GWorld	GetGWorld (&savePort, &saveDevice);	SetGWorld (pictWorld, NULL);	DrawPicture(picture, &pictRect);	SetGWorld (savePort, saveDevice);	newpicture = GetPixBaseAddr( pictPix);	for( int a=0; a<pictRect.bottom;a++)		{		memcpy( where, newpicture, 256);		where += 256;		newpicture += ((**pictPix).rowBytes & 0x3fff);		}	// Succeeded in creating the texture, cleanup everything else and return	goto cleanup;	error:	// if we have a texture, dispose of it, because we want to return NULLcleanup:	if (picture != NULL)		ReleaseResource ((Handle) picture);	if (pictWorld != NULL)		DisposeGWorld (pictWorld);	return true;}*/#endif