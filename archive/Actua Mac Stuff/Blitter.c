#include "Mac Vars.h"#include "Blitter.h"#include <Displays.h>#undef EXTERN#define EXTERN extern#include "Palette.h"#include "Use DrawSprockets.h"#include "Mallocx.h"#include "3deng.h"#define SAVE(Y,X)   Y[X]=a, Y[X+1]=b, Y[X+2]=c, Y[X+3]=d;#define LOAD(Y,X)	a=Y[X], b=Y[X+1], c=Y[X+2], d=Y[X+3];	BYTE screenptr[640][480];void ClearBuffer(){	memset( screenptr, 0, 640*480);}void ClearScreen(){int lines = 0;char *dest = gScreenAddr;	while(lines<gScreenRealHeight)		{		memset( dest, 0, gScreenRealWidth);		lines++;		dest += gScreenRowBytes;		}}GrafPtr			savePort;Rect			windRect;PixMapHandle	mainScreenPixMap;DisplayIDType theID;void OpenMyWindow(){Rect windRect;	DSpContext_GetDisplayID( theContext, &theID );	DMGetGDeviceByDisplayID( theID, &gameScreen, false );	windRect = (**gameScreen).gdRect;	myWindow = GetNewCWindow( wMyWindow, nil, (WindowPtr)-1L);	( (WindowPeek) myWindow) -> refCon = wMyWindow;	GetPort( &savePort );	SetPort( myWindow );	MoveWindow( myWindow, windRect.left, windRect.top, true );	SizeWindow( myWindow, (windRect.right - windRect.left), (windRect.bottom - windRect.top), true );	ShowWindow( myWindow );}void CloseMyWindow(){	HideWindow( myWindow ); 	DisposeWindow( myWindow );	SetPort( savePort );}void BlitterInit(void){	DSpContext_GetDisplayID( theContext, &theID );	DMGetGDeviceByDisplayID( theID, &gameScreen, false );	mainScreenPixMap = (**gameScreen).gdPMap;						// get screen pixMap	windRect = (**gameScreen).gdRect;		LockPixels(mainScreenPixMap); 	gScreenAddr = StripAddress(GetPixBaseAddr(mainScreenPixMap));	// make non-32bit friendly	gScreenRowBytes = (long)(0x7FFF&(**mainScreenPixMap).rowBytes);	// calc screen's rowBytes	gScreenRows = (long) (0x7FFF & ( **mainScreenPixMap).bounds.bottom);//	screenptr = (unsigned char *)MallocX(640*480);	gScreenRealWidth = myRealAttributes.displayWidth;	gScreenRealHeight = myRealAttributes.displayHeight;	BlitterMode = REAL_640480;}void BlitterEnd(){	UnlockPixels(mainScreenPixMap);//	FreeX(screenptr);}asm void DoubleAcross(long *dest, unsigned char *src, short width, short addition, short height){	lwz		r10, src	lwz		r7, dest	addi	r10, r10, -4	addi	r7, r7, -4	lhz		r6, height@l0	lhz		r0, addition	add		r11, r7, r0	add		r11, r11, r0	add		r12, r11, r0	mr		r7, r11		mr		r14, r10	lhz		r0, width	mtctr	r0@l1	lwzu	r5, 4(r10)	mr		r13, r5	rlwimi	r13, r5, 24, 8, 23	rlwimi	r13, r5, 16, 24, 31	stwu	r13, 4(r11)	stwu	r13, 4(r12)	mr	r13, r5	rlwimi	r13, r5, 16, 0, 15	rlwimi	r13, r13, 8, 8, 23	stwu	r13, 4(r11)	stwu	r13, 4(r12)	lwzu	r5, 4(r10)	mr		r13, r5	rlwimi	r13, r5, 24, 8, 23	rlwimi	r13, r5, 16, 24, 31	stwu	r13, 4(r11)	stwu	r13, 4(r12)	mr	r13, r5	rlwimi	r13, r5, 16, 0, 15	rlwimi	r13, r13, 8, 8, 23	stwu	r13, 4(r11)	stwu	r13, 4(r12)	bdnz	@l1		addi	r10, r14, 320	addi	r6, r6, -1	cmpi	cr0, 0, r6, 0	bne+	@l0		blr}static Boolean BlitterCallBack( DSpContextReference theContext, void *inRefCon){	return false;}void BlitBufferToScreen(double *srcPtr){/*CGrafPtr newBuffer;	DSpContext_SwapBuffers( theContext,  BlitterCallBack, NULL);	DSpContext_GetBackBuffer( theContext, kDSpBufferKind_Normal, &newBuffer);*/		#if USERAVEENGINE==YES{unsigned short *scr;BYTE *src = (BYTE *)srcPtr;	scr  =  (unsigned short *)((BYTE *)gScreenAddr + (((gScreenRealHeight - 480)/2 ) * gScreenRowBytes) + (((gScreenRealWidth - 640)/2)*2));	for( int y1=0; y1<480; y1++)		{		for( int a=0; a<640; a++)			scr[a] = palette_buffer16[src[a]];		scr += (gScreenRowBytes>>1);		src += 640;		}}#else	switch(BlitterMode)		{		case DOUBLE_320200:	  			BlitDouble320(srcPtr, 200);	  			break;		case DOUBLE_320240:	  			BlitDouble320(srcPtr, 240);	  			break;		case REAL_640400:	  			BlitReal640(srcPtr, 400);	  			break;		case REAL_640480:	  			BlitReal640(srcPtr, 480);				break;		}	if( PaletteChange)		{		BuildPalette( palette_buffer);		PaletteChange = false;		}#endif}extern setup_info setup;void BlitDouble320(double *srcPtr, short height){long    width = 320/sizeof(double);BYTE	*destPtr;   	destPtr = (BYTE *)gScreenAddr + ((((gScreenRealHeight - height - height)/2)-2) * gScreenRowBytes) + ((gScreenRealWidth - 640)/2);	DoubleAcross((long *)destPtr, (unsigned char *)srcPtr, width, gScreenRowBytes, height);}void BlitReal640(double *srcPtr, short y1){register char	*destPtr = (char *)gScreenAddr;			// get ptr to start of scan lineregister long	rowBytes = gScreenRowBytes;double *q;double a,b,c,d;	destPtr += (((gScreenRealHeight - y1)/2 ) * rowBytes) + ((gScreenRealWidth - 640)/2);	while(y1--)		{		q = (double *)destPtr;		LOAD(srcPtr,0); SAVE(q,0);		LOAD(srcPtr,76); SAVE(q,76);		LOAD(srcPtr,4); SAVE(q,4);		LOAD(srcPtr,72); SAVE(q,72);		LOAD(srcPtr,8); SAVE(q,8);		LOAD(srcPtr,68); SAVE(q,68);		LOAD(srcPtr,12); SAVE(q,12);		LOAD(srcPtr,64); SAVE(q,64);		LOAD(srcPtr,16); SAVE(q,16);		LOAD(srcPtr,20); SAVE(q,20);		LOAD(srcPtr,24); SAVE(q,24);		LOAD(srcPtr,28); SAVE(q,28);		LOAD(srcPtr,32); SAVE(q,32);		LOAD(srcPtr,36); SAVE(q,36);		LOAD(srcPtr,40); SAVE(q,40);		LOAD(srcPtr,44); SAVE(q,44);		LOAD(srcPtr,48); SAVE(q,48);		LOAD(srcPtr,52); SAVE(q,52);		LOAD(srcPtr,56); SAVE(q,56);		LOAD(srcPtr,60); SAVE(q,60);		destPtr += gScreenRowBytes;		srcPtr+=(640/8);		}}/*asm void AsmBlockCopy( BYTE *dest, BYTE *src, short width, short height, short addition){	lwz		r10, src	lwz		r11, dest	lhz		r0, width	lhz		r5, addition	lhz		r6, height	li		r7, 640	sub		r5, r5, r0	sub		r7, r7, r0		addi	r10, r10, -1	addi	r11, r11, -1@l0	lhz		r0, width	mtctr	r0@l1	lbzu	r8, 1(r10)	stbu	r8, 1(r11)	bdnz	@l1		add		r10, r10, r7	add		r11, r11, r5	addi	r6, r6, -1	cmpi	cr0, 0, r6, 0	bne+	@l0		blr}*/void BlockCopy(char *srcPtr, short x, short y, short x1, short y1){#if USERAVEENGINE==YES{unsigned short *scr;	scr  =  (unsigned short *)((BYTE *)gScreenAddr + (((gScreenRealHeight - 480)/2 ) * gScreenRowBytes) + (((gScreenRealWidth - 640)/2)*2) + (y * gScreenRowBytes) + x+x);		while( y1-- && y<480)		{		for( int a=0; a<x1; a++)			scr[a] = palette_buffer16[srcPtr[a]];		scr += (gScreenRowBytes>>1);		srcPtr += 640;		}}#else{char	*destPtr;	destPtr =  (char *)gScreenAddr + (((gScreenRealHeight - 480)/2 ) * gScreenRowBytes) + ((gScreenRealWidth - 640)/2);	destPtr += (y * gScreenRowBytes) + x;	while(y1-- && y<480)  		{		for(int a=0;a<x1;a++)			destPtr[a]=srcPtr[a];		destPtr += gScreenRowBytes;		srcPtr += 640;		y++;	  	}}#endif}#if USERAVEENGINE==YESvoid Blit320To16Bits( BYTE *screenptr){unsigned short *scr;	scr  =  (unsigned short *)((BYTE *)gScreenAddr + (((gScreenRealHeight - 480)/2 ) * gScreenRowBytes) + (((gScreenRealWidth - 640)/2)*2) );	for( int b=0; b<240; b++)		{		for( int a=0, b=0; a<320; a++)			scr[ b] = scr[ b+1] = scr[ b+640] = scr[ b+641] = palette_buffer16[ screenptr[a]], b+=2;		screenptr+=320;		scr+=1280;		}}#endif