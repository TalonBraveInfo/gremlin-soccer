#include "Frontend Vars.h"#include "Palette.h"#undef EXTERN#define EXTERN extern#include "Blitter.h"#include "Flc Player.h"#include "Front Variables.h"#include "Menudisp.h"#include "Mouse.h"#include "Use DrawSprockets.h"#include "MallocX.h"static Boolean FadedDown = false;static int Fade_Speed;static BYTE PULSEtable[] = { 0x16, 0x1C, 0x23, 0x2A, 0x31, 0x38, 0x3F, 0x3A, 0x36, 0x31, 0x2C, 0x28, 0x23, 0x1F, 0x1A, 0x16, 0x16 };void BuildPalette(BYTE *palette){int i;#if USERAVEENGINE!=YESColorSpec   cs[256];#endif	if( !FlcPlaying)		{		palette_buffer[0] = palette_buffer[1] = palette_buffer[2] = 63;		palette_buffer[255*3+0] = palette_buffer[255*3+1] = palette_buffer[255*3+2] = 0;		}#if USERAVEENGINE==YES	for(i=0; i<256; i++)		{		palette[0] &= 63; palette[1] &= 63; palette[2] &= 63;		palette_buffer16[i] = ((palette[0]>>1)<<10)|((palette[1]>>1)<<5)|((palette[2]>>1))|0x8000;		palette+=3;		}	#else	for(i=0; i<256; i++)		{		cs[i].value = i;		cs[i].rgb.red = palette[0]<<10;		cs[i].rgb.green = palette[1]<<10;		cs[i].rgb.blue = palette[2]<<10;		palette+=3;		}		DSpContext_SetCLUTEntries( theContext, (ColorSpec *)&cs, 0, 255);#endif	DSpContext_FadeGamma( theContext, PalettePercent, NULL); }void PulsateColour(int colour){BYTE c = PULSEtable[colour&15];ColorSpec cs;	palette_buffer[ 175*3] = palette_buffer[ 175*3+1] = palette_buffer[ 175*3+2] = c;	cs.value = 175;	cs.rgb.red = cs.rgb.green = cs.rgb.blue = c <<10;#if USERAVEENGINE==YES	BuildPalette( palette_buffer);#else	DSpContext_SetCLUTEntries( theContext, (ColorSpec *)&cs, 175, 0);#endif}void FadeThePalette(void){short color;#if DEBUGGING==ON//	if(PaletteFlag == 1 || PaletteFlag==3)//	  PaletteFlag = 0;//	return;#endif	switch(PaletteFlag)	  {	  case 0:	  			break;	  case 1:	Fade_Speed = FADE_SPEED;	  			PaletteFlag++;	  			BuildPalette( palette_buffer);	  			BlitBufferToScreen( (double *)screenptr);	  			break;	  case 2:	// Fade Up				--Fade_Speed;				if( FadedDown)#if DEBUGGING==OFF				  DSpContext_FadeGamma( theContext, PalettePercent = (100-(Fade_Speed *(100/FADE_SPEED))), NULL); #else				  DSpContext_FadeGamma( theContext, PalettePercent = (100-(Fade_Speed *5)), NULL); #endif	  			if(!Fade_Speed)	  			  {	  			  PaletteFlag = 0;	  			  FadedDown = false;	  			  }	  			break;	  case 3:	Fade_Speed = FADE_SPEED;	  			PaletteFlag++;	  			BuildPalette( palette_buffer);	  			break;	  case 4:	// Fade Down				--Fade_Speed;				if(!FadedDown)#if DEBUGGING==OFF				  DSpContext_FadeGamma( theContext, PalettePercent = (Fade_Speed *(100/FADE_SPEED)), NULL); #else				  DSpContext_FadeGamma( theContext, PalettePercent = (50 + Fade_Speed *5), NULL); #endif	  			if(!Fade_Speed)	  			  {	  			  PaletteFlag = 0;	  			  FadedDown = true;	  			  }	  			break;	  }}void ClearPalette(){}void Set_palette_to_black(void){#if DEBUGGING==OFF	if(!FadedDown)		{		DSpContext_FadeGammaOut( NULL/*theContext*/, NULL);		PalettePercent = 0;		}#endif	FadedDown = true;}void RevertToMac(){	Get_mouse_data();	Dump_copy_list();	DSpContext_SetState(theContext, kDSpContextState_Paused);	FlushEvents( everyEvent, 0x0000);}void RevertToGame(){	MouseFlags &= ~MOUSE_OFF;	DSpContext_SetState(theContext, kDSpContextState_Active);   	BlitBufferToScreen( (double *) psudo_buffer);	FlushEvents( everyEvent, 0x0000);}